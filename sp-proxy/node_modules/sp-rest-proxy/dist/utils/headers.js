"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHeaders = exports.copyHeaders = exports.getHeader = exports.mergeHeaders = void 0;
var node_fetch_1 = require("node-fetch");
var mergeHeaders = function () {
    var headers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        headers[_i] = arguments[_i];
    }
    var res = new node_fetch_1.Headers();
    for (var _a = 0, headers_1 = headers; _a < headers_1.length; _a++) {
        var hh = headers_1[_a];
        if (hh) {
            hh.forEach(function (val, key) {
                if (val) {
                    res.set(key, val);
                }
                else {
                    res.delete(key);
                }
            });
        }
    }
    return res;
};
exports.mergeHeaders = mergeHeaders;
var getHeader = function (headers, header) {
    var res = null;
    Object.keys(headers).forEach(function (key) {
        if (key.toLowerCase() === header.toLowerCase()) {
            var val = headers[key];
            if (typeof val === 'string') {
                res = val;
            }
            else {
                res = val[0];
            }
        }
    });
    return res;
};
exports.getHeader = getHeader;
var copyHeaders = function (resp, headers, copy, ignore) {
    if (copy === void 0) { copy = []; }
    if (ignore === void 0) { ignore = []; }
    copy = copy.map(function (k) { return k.toLowerCase(); });
    ignore = ignore.map(function (k) { return k.toLowerCase(); });
    headers.forEach(function (val, key) {
        if (ignore.indexOf(key.toLowerCase()) === -1) {
            if (copy.length === 0 || copy.indexOf(key.toLowerCase()) !== -1) {
                resp.setHeader(key, val);
            }
        }
    });
};
exports.copyHeaders = copyHeaders;
var getHeaders = function (reqHeaders, ignoreHeaders) {
    if (ignoreHeaders === void 0) { ignoreHeaders = []; }
    var headers = new node_fetch_1.Headers();
    var ignoreDefaults = ['host', 'referer', 'origin'];
    ignoreHeaders = __spreadArray(__spreadArray([], ignoreHeaders.map(function (h) { return h.toLowerCase(); }), true), ignoreDefaults, true);
    Object.keys(reqHeaders).forEach(function (prop) {
        if (ignoreHeaders.indexOf(prop.toLowerCase()) === -1) {
            headers.set(prop, (0, exports.getHeader)(reqHeaders, prop));
        }
    });
    return headers;
};
exports.getHeaders = getHeaders;
//# sourceMappingURL=headers.js.map